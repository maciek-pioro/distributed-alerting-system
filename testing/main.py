import json
import os
import random
import sys
import time
import requests
import asyncio
from google.cloud import firestore, pubsub_v1, logging
from pymailtm import MailTm, Account
from pymailtm.pymailtm import generate_username, CouldNotGetAccountException, InvalidDbAccountException, open_webbrowser, Message

project_id = "irio-solution"
topic_id = os.getenv("TOPIC_ID")
uuids_db_name = os.getenv("UUIDS_DB_NAME")
emails_send_db_name = os.getenv("EMAILS_SENT_DB_NAME")
bad_url = "404"


def extract_url_and_uuid_from_msg(msg):
    ack_url = msg.text # TODO extract ack url when the mail format is known, for now assuming that text of an email consists only of the url

    tmp1 = ack_url.split('/') # ['https:', '', 'ack-server-rlvishyx4a-uc.a.run.app', '?admin=<admin_number>&uuid=<outage_uuid>']
    tmp2 = tmp1[-1].split('=') # ['?admin', '<admin_number>&uuid', '<outage_uuid>']
    uuid = tmp2[-1]
    return (ack_url, uuid)

def find_appropriate_log(logging_client, logger_name, pattern):
    logger = logging_client.logger(logger_name)
    for entry in logger.list_entries():
        if pattern in entry.payload:
            return True
    return False

async def first_admin_reponds(db_client, publisher, topic_path, logging_client):
    # setup temporary email
    tm = MailTm()
    acc = tm.get_account()
    temp_email_address = acc.address

    # send message about outage to first_sender via pub/sub
    msg = {"url": bad_url, "email_address": temp_email_address, "allowed_response_time_in_seconds": 60*60} # TODO and other things that email_sender needs
    data = json.dumps(msg)
    try:
        publisher.publish(topic_path, data).result()
    except Exception as e:
        print(json.dumps({"message": f"Could not publish msg into topic {topic_path}", "severity": "ERROR"}))
        sys.exit(1)

    # obtain outage uuid generated by first_sender
    time.sleep(60)
    doc_ref = db_client.collection(uuids_db_name).document(bad_url)
    uuid = doc_ref.uuid

    # check if first_sender properly logged
    if not find_appropriate_log(logging_client, "outages", f"Email about outage {uuid} sent to the first admin"): # TODO consult logging content
        print(json.dumps({"message": f"ERROR: Could not find log about first email sent. Url: {bad_url}, uuid: {uuid}", "severity": "ERROR"}))

    # wait for an email with outage info and link to come
    msg = acc.wait_for_message()
    (ack_url, uuid) = extract_url_and_uuid_from_msg(msg)

    # click the link
    res = requests.get(ack_url)
    if not res.ok():
        raise Exception(f"ack_link response error: {res}")
        print(json.dumps({"message": f"Could not request ack link. Res: {res}, ack_url: {ack_url}", "severity": "ERROR"}))
        sys.exit(1)

    # check if ack server propely logged
    if not find_appropriate_log(logging_client, "outages", f"Admin 1 acknowledged outage {uuid}"):
        print(json.dumps({"message": f"Could not find log about first admin acknowlegdment sent. Url: {bad_url}, uuid: {uuid}", "severity": "ERROR"}))

    # check that uuid is no longer present in emails_send store
    if db_client.collection(emails_send_db_name).document(uuid).get().to_dict() is not None:
        print(json.dumps({"message": f"ERROR: Uuid {uuid} still present in {emails_send_db_name} db after admin acknowlegded the outage.", "severity": "ERROR"}))


def main():
    db_client = firestore.Client(project=project_id)
    logging_client = logging.Client()
    publisher = pubsub_v1.PublisherClient()
    topic_path = publisher.topic_path(project_id, topic_id)
    first_admin_reponds(db_client, publisher, topic_path, logging_client)


if __name__ == "__main__":
    #main()
    print("Job is up and running")

"""
# Define main script
def main(sleep_ms=0, fail_rate=0):
    print(f"Starting Task #{TASK_INDEX}, Attempt #{TASK_ATTEMPT}...")
    # Simulate work by waiting for a specific amount of time
    time.sleep(float(sleep_ms) / 1000)  # Convert to seconds

    # Simulate errors
    random_failure(float(fail_rate))

    print(f"HALKOOOOOO Completed Task #{TASK_INDEX}.")


# Throw an error based on fail rate
def random_failure(rate):
    if rate < 0 or rate > 1:
        # Return without retrying the Job Task
        print(
            f"Invalid FAIL_RATE env var value: {rate}. " +
            "Must be a float between 0 and 1 inclusive."
        )
        return

    random_failure = random.random()
    if random_failure < rate:
        raise Exception("Task failed.")


# Start script
if __name__ == "__main__":
    try:
        main(SLEEP_MS, FAIL_RATE)
    except Exception as err:
        message = f"Task #{TASK_INDEX}, " \
                  + f"Attempt #{TASK_ATTEMPT} failed: {str(err)}"

        print(json.dumps({"message": message, "severity": "ERROR"}))
        sys.exit(1)  # Retry Job Task by exiting the process
"""