import json
import os
import sys
import time
import requests
from google.cloud import firestore, pubsub_v1, logging
from pymailtm import MailTm

project_id = "irio-solution"
topic_id = os.getenv("TOPIC_ID", "first_sender_topic")
uuids_db_name = os.getenv("UUIDS_DB_NAME", "uuids")
emails_send_db_name = os.getenv("EMAILS_SENT_DB_NAME", "emails_sent")
bad_url = "404"


def extract_url_and_uuid_from_msg(msg):
    ack_url = msg.text # TODO extract ack url when the mail format is known, for now assuming that text of an email consists only of the url

    tmp1 = ack_url.split('/') # ['https:', '', 'ack-server-rlvishyx4a-uc.a.run.app', '?admin=<admin_number>&uuid=<outage_uuid>']
    tmp2 = tmp1[-1].split('=') # ['?admin', '<admin_number>&uuid', '<outage_uuid>']
    uuid = tmp2[-1]
    return (ack_url, uuid)

def find_appropriate_log(logging_client, logger_name, pattern):
    logger = logging_client.logger(logger_name)
    for entry in logger.list_entries():
        if pattern in entry.payload:
            return True
    return False

def first_admin_reponds(db_client, publisher, topic_path, logging_client):
    # setup temporary email
    tm = MailTm()
    acc = tm.get_account()
    temp_email_address = acc.address

    # send message about outage to first_sender via pub/sub
    msg = {"url": bad_url, "email_address": temp_email_address, "allowed_response_time_in_seconds": 60*60} # TODO and other things that email_sender needs
    data = json.dumps(msg)
    try:
        publisher.publish(topic_path, data).result()
    except Exception as e:
        print(json.dumps({"message": f"Could not publish msg into topic {topic_path}: {e}", "severity": "ERROR"}))
        sys.exit(1)

    # obtain outage uuid generated by first_sender
    time.sleep(60)
    doc_ref = db_client.collection(uuids_db_name).document(bad_url)
    uuid = doc_ref.uuid

    # check if first_sender properly logged
    if not find_appropriate_log(logging_client, "outages", f"Email about outage {uuid} sent to the first admin"): # TODO consult logging content
        print(json.dumps({"message": f"ERROR: Could not find log about first email sent. Url: {bad_url}, uuid: {uuid}", "severity": "ERROR"}))

    # wait for an email with outage info and link to come
    msg = acc.wait_for_message()
    (ack_url, uuid) = extract_url_and_uuid_from_msg(msg)

    # click the link
    res = requests.get(ack_url)
    if not res.ok():
        print(json.dumps({"message": f"Could not request ack link. Res: {res}, ack_url: {ack_url}", "severity": "ERROR"}))
        sys.exit(1)

    # check if ack server propely logged
    if not find_appropriate_log(logging_client, "outages", f"Admin 1 acknowledged outage {uuid}"):
        print(json.dumps({"message": f"Could not find log about first admin acknowlegdment sent. Url: {bad_url}, uuid: {uuid}", "severity": "ERROR"}))

    # check that uuid is no longer present in emails_send store
    if db_client.collection(emails_send_db_name).document(uuid).get().to_dict() is not None:
        print(json.dumps({"message": f"ERROR: Uuid {uuid} still present in {emails_send_db_name} db after admin acknowlegded the outage.", "severity": "ERROR"}))


def main():
    db_client = firestore.Client(project=project_id)
    logging_client = logging.Client()
    publisher = pubsub_v1.PublisherClient()
    topic_path = publisher.topic_path(project_id, topic_id)
    first_admin_reponds(db_client, publisher, topic_path, logging_client)


if __name__ == "__main__":
    main()